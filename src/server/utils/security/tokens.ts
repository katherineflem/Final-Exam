// import * as crypto from 'crypto'
// import * as jwt from 'jsonwebtoken'
// // import db from '../../db'
// // import config from '../../config'

// //INSERTING OUR USER INTO OUR TOKENS TABLE(USING FK USERID)
// //GENERATE A KEY AND UPDATE THE NEW USER ROW WITH THE KEY
// //RETURN TOKEN FOR USE

// //create a token
// //insert userid into tokens table
// //update our payload with that row's id
// //generate a unique property using crypto library(already built in node)
// //jwt sign the token using a secret key
// //update that row with our newly signed token
// //return that token


// export const CreateToken = async (payload: IPayload) => {
//     let {insertId}: any = await db.Tokens.insertToken(payload.userid); //inserted row in the tokens table, these are auto-incrementing
//     payload.accesstokenid = insertId;// insertId is the default mysql response for what was just inserted
//     payload.unique = crypto.randomBytes(32).toString('hex');//hex is a type of code like the color codes
//     let token = await jwt.sign(payload, config.auth.secret)
//     console.log(token)
//     await db.Tokens.updateRow(token, payload.accesstokenid);
//     return token;
// };

// export const ValidateToken = async (token: string) => {
//     let payload = <IPayload>jwt.decode(token);
//     let [accesstokenid]:any  = await db.Tokens.findOneToken(payload.accesstokenid, token);
//     if (!accesstokenid) {
//         throw new Error('Invalid Token')
//     } else {
//         return payload;
//     }
// }
// export interface IPayload {
//     userid: number,
//     unique?: string //generated by crypto- doesnt exist until later hence the ?
//     accesstokenid?: number
// }